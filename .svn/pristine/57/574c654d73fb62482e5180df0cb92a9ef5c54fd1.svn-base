using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using Hexas;
using Misc;
using Characters;
using AI_Util;
using Classifiers;
using static MainGame;

namespace AI_Class {
	
	
public class ActionAIPos{
	public MainGame.ActionType action;
	public Point pos;
	
	public ActionAIPos(MainGame.ActionType action,Point pos){
		this.action = action;
		this.pos = pos;
	}
}

public class AI{
	public static HexaGrid hexaGrid;
	
	
	
	public static List<ActionAIPos> decide(int charID){
		List<ActionAIPos> sequence = new List<ActionAIPos>();
		sequence.Add(new ActionAIPos(MainGame.ActionType.SKIP,null));
		return sequence;
	}
}

public class AIEasy : AI {
	new public static List<ActionAIPos> decide(int charID){
		Character currentChar = hexaGrid.charList[charID];
		List<ActionAIPos> sequence = new List<ActionAIPos>();
		
		switch (currentChar.charClass){
			case CharClass.GUERRIER :
			case CharClass.VOLEUR :
			case CharClass.ARCHER :
			case CharClass.MAGE : {
				int[] damage = AIUtil.calculateDamage(charID);
				List<Point> listH = hexaGrid.findAllPaths(currentChar.x,currentChar.y,currentChar.PM*currentChar.PA);
				if (listH != null && listH.Count > 0){
					// Find hexas where damage dealt is highest
					List<Point> bestHexas  = AIUtil.findHexasWhereValueIsMax(listH,damage);
					// Find hexas where position to lowest ennemy is lowest
					List<Point> bestHexas2 = AIUtil.findHexasClosestToLowestEnnemy(charID,bestHexas);
					Point bestHexa = bestHexas2[0];
					// find path to hexa
					sequence = AIUtil.findSequencePathToHexa(charID,bestHexa.x,bestHexa.y);
					// Attack the ennemy
					int nbPA = currentChar.PA - sequence.Count;
					if (nbPA != 0){
						for (int i=0;i<nbPA;i++){
							Character cAttack = AIUtil.findCharToAttack(charID);
							if (cAttack != null){
								sequence.Add(new ActionAIPos(MainGame.ActionType.ATK1,new Point(cAttack.x,cAttack.y)));
							}else if (bestHexa.x == currentChar.x && bestHexa.y == currentChar.y){
								sequence.Add(new ActionAIPos(MainGame.ActionType.SKIP,null));
							}
						}
					}
				}else{
					sequence.Add(new ActionAIPos(MainGame.ActionType.SKIP,null));
				}
			} break;
			case CharClass.SOIGNEUR : {
				int[] healing = AIUtil.calculateHealing(charID);
				List<Point> listH = hexaGrid.findAllPaths(currentChar.x,currentChar.y,currentChar.PM*currentChar.PA);
				if (listH != null && listH.Count > 0){
					// Find hexas where healing done is highest
					List<Point> bestHexas  = AIUtil.findHexasWhereValueIsMax(listH,healing);
					// Find hexas where position to lowest ennemy is lowest
					List<Point> bestHexas2 = AIUtil.findHexasClosestToLowestEnnemy(charID,bestHexas);
					Point bestHexa = bestHexas2[0];
					// find path to hexa
					sequence = AIUtil.findSequencePathToHexa(charID,bestHexa.x,bestHexa.y);
					int nbPA = currentChar.PA - sequence.Count;
					// Heal allies
					if (nbPA != 0){
						for (int i=0;i<nbPA;i++){
							Character cHeal = AIUtil.findCharToHeal(charID);
							if (cHeal != null){
								sequence.Add(new ActionAIPos(MainGame.ActionType.ATK1,new Point(cHeal.x,cHeal.y)));
							}else if (bestHexa.x == currentChar.x && bestHexa.y == currentChar.y){
								sequence.Add(new ActionAIPos(MainGame.ActionType.SKIP,null));
							}
						}
					}
				}else{
					sequence.Add(new ActionAIPos(MainGame.ActionType.SKIP,null));
				}
			} break;
			// TO DO
			case CharClass.ENVOUTEUR : {
				int[] healing = AIUtil.calculateBuff(charID);
				List<Point> listH = hexaGrid.findAllPaths(currentChar.x,currentChar.y,currentChar.PM*currentChar.PA);
				if (listH != null && listH.Count > 0){
					// Find hexas where healing done is highest
					List<Point> bestHexas  = AIUtil.findHexasWhereValueIsMax(listH,healing);
					// Find hexas where position to lowest ennemy is lowest
					List<Point> bestHexas2 = AIUtil.findHexasClosestToLowestEnnemy(charID,bestHexas);
					Point bestHexa = bestHexas2[0];
					// find path to hexa
					sequence = AIUtil.findSequencePathToHexa(charID,bestHexa.x,bestHexa.y);
					int nbPA = currentChar.PA - sequence.Count;
					// Buff allies
					if (nbPA != 0){
						for (int i=0;i<nbPA;i++){
							Character cBuff = AIUtil.findCharToBuff(charID);
							if (cBuff != null){
								sequence.Add(new ActionAIPos(MainGame.ActionType.ATK1,new Point(cBuff.x,cBuff.y)));
							}else if (bestHexa.x == currentChar.x && bestHexa.y == currentChar.y){
								sequence.Add(new ActionAIPos(MainGame.ActionType.SKIP,null));
							}
						}
					}
				}else{
					sequence.Add(new ActionAIPos(MainGame.ActionType.SKIP,null));
				}
			} break;
		}
		
		return sequence;
	}
}

public class AIMedium : AI{
	new public static List<ActionAIPos> decide(int charID){
		Character currentChar = hexaGrid.charList[charID];
		List<ActionAIPos> sequence = new List<ActionAIPos>();
		
		switch (currentChar.charClass){
			case CharClass.GUERRIER :
			case CharClass.VOLEUR :
			case CharClass.ARCHER :
			case CharClass.MAGE : {
				int[] threat = AIUtil.calculateThreat(currentChar.team);
				int[] damage = AIUtil.calculateDamage(charID);
				int[] dif = new int[hexaGrid.w*hexaGrid.h];
				
				for (int i=0;i<dif.Length;i++){
					dif[i] = (int)(1.5f*damage[i] - (float)threat[i]);
				}
				
				List<Point> listH = hexaGrid.findAllPaths(currentChar.x,currentChar.y,currentChar.PM*currentChar.PA);
				if (listH != null && listH.Count > 0){
					// find best value
					int maxValue = dif[listH[0].x+listH[0].y*hexaGrid.w];
					foreach (Point p in listH){
						int v = dif[p.x+p.y*hexaGrid.w];
						if (v > maxValue) maxValue = v;
					}
					// find all hexas with best value
					List<Point> bestHexas = new List<Point>();
					foreach (Point p in listH){
						int v = dif[p.x+p.y*hexaGrid.w];
						if (v == maxValue) bestHexas.Add(p);
					}
					// find the hexa with best value closest to lowest ennemy
					Point bestHexa = null;
					if (bestHexas.Count == 1){
						bestHexa = bestHexas[0];
					}else{
						int minDistance = 100000;
						bestHexa = null;
						Character cLowest = AIUtil.findLowestEnnemy(currentChar.team);
						foreach (Point p in bestHexas){
							int d = AIUtil.getDistance(p.x,p.y,cLowest.x,cLowest.y);
							if (d != -1){
								if (d < minDistance){
									minDistance = d;
									bestHexa = p;
								}
							}
						}
					}
					// find path to hexa
					int nbPA = currentChar.PA;
					if (bestHexa != null){
						if (bestHexa.x == currentChar.x && bestHexa.y == currentChar.y){
							
						}else{
							int d = AIUtil.getDistance(currentChar.x,currentChar.y,bestHexa.x,bestHexa.y);
							List<Point> shortestPath = hexaGrid.findShortestPath(currentChar.x,currentChar.y,bestHexa.x,bestHexa.y,d);
							for (int i=0;i<=d && nbPA > 0;i+=currentChar.PM){
								Point destination = shortestPath[((i+currentChar.PM) <= d) ? (i+currentChar.PM) : d];
								sequence.Add(new ActionAIPos(MainGame.ActionType.MOVE,new Point(destination.x,destination.y)));
								nbPA--;
							}
						}
						if (nbPA == 0){
							
						}else{
							for (int i=0;i<nbPA;i++){
								Character cAttack = AIUtil.findCharToAttack(charID);
								if (cAttack != null){
									sequence.Add(new ActionAIPos(MainGame.ActionType.ATK1,new Point(cAttack.x,cAttack.y)));
								}else if (bestHexa.x == currentChar.x && bestHexa.y == currentChar.y){
									sequence.Add(new ActionAIPos(MainGame.ActionType.SKIP,null));
								}
							}
							
						}
					}else{
						sequence.Add(new ActionAIPos(MainGame.ActionType.SKIP,null));
					}
				}else{
					sequence.Add(new ActionAIPos(MainGame.ActionType.SKIP,null));
				}
			} break;
			case CharClass.SOIGNEUR : {
				sequence.Add(new ActionAIPos(MainGame.ActionType.SKIP,null));
			} break;
			case CharClass.ENVOUTEUR : {
				sequence.Add(new ActionAIPos(MainGame.ActionType.SKIP,null));
			} break;
		}
		
		return sequence;
	}
}

public class AIHard : AI{
	public static ClassifierSystem rules;
	
	new public static List<ActionAIPos> decide(int charID){
		Character currentChar = hexaGrid.charList[charID];
		List<ActionAIPos> sequence = new List<ActionAIPos>();
		
		// Get the current situation
		Classifier currentSituation = new Classifier(hexaGrid,charID);
		currentSituation.display();
		// Find matching classifiers to the current situation in the database 
		List<Classifier> matchingRules = rules.findMatchingClassifiers(currentSituation);
		// Add the classifier to the database if no match is found
		if (matchingRules.Count == 0){
			Debug.Log("Pas trouvé : on ajoute");
			matchingRules.Add(currentSituation);
			rules.Add(currentSituation);
		}else{
			Debug.Log("Trouvé " + matchingRules.Count + " règle(s)");
		}
		
		Classifier rule = matchingRules[0];

		// Convert the action from the classifier to an action that can be executed in game
		switch (rule.action){
			//case Classifier.Action.RandomMovement : Debug.Log("Random movement");
			///sequence.Add(new ActionAIPos(MainGame.ActionType.SKIP,null));
			//break;
			
			case Classifier.Action.RandomMovement  :Debug.Log("Attaque");
			int[] damage = AIUtil.calculateDamage(charID);
			List<Point> listH = hexaGrid.findAllPaths(currentChar.x,currentChar.y,currentChar.PM*currentChar.PA);
			
			if (listH != null && listH.Count > 0){
				
			List<Point> bestHexas  = AIUtil.findHexasWhereValueIsMax(listH,damage);
			Character cAttackIAD = AIUtil.findCharToAttack(charID);
			if (cAttackIAD != null){
			sequence.Add(new ActionAIPos(MainGame.ActionType.ATK1,new Point(cAttackIAD.x,cAttackIAD.y)));
			}else 
			sequence.Add(new ActionAIPos(MainGame.ActionType.SKIP,null));
			
			}
			break;
			default :  Debug.Log("???"); break;
		}
		
		
		return sequence;
	}
}

}
