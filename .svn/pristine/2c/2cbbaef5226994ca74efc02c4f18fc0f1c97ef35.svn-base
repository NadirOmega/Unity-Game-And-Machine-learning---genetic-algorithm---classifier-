using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using Misc;
using Hexas;
using Characters;
using AI_Class;
using static MainGame;

namespace AI_Util {

public class HexaDamage{
	int x;
	int y;
	int value;
	
	public HexaDamage(int x,int y,int value){
		this.x = x;
		this.y = y;
		this.value = value;
	}
}

public class AIUtil{
	public static HexaGrid hexaGrid;
	
	/** Calculates how much damage can potentially be taken on each hexa.
		Returns a list of w*h that contains the data. */
	public static int[] calculateThreat(int team){
		int w_h = hexaGrid.w * hexaGrid.h;
		int[] finalList = new int[w_h];
		int[] list = new int[w_h];
		for (int i=0;i<w_h;i++){
			finalList[i] = 0;
			list[i] = 0;
		}
		List<Point> junk;
		
		foreach (Character c in hexaGrid.charList){
			if (c.team != team && c.charClass != CharClass.SOIGNEUR && c.charClass != CharClass.ENVOUTEUR){
				int damage = c.getClassData().basicAttack.effectValue;
				// 0 PM
				List<Point> listHexasInSight = hexaGrid.findHexasInSight(c.x,c.y,c.getClassData().basicAttack.range,out junk);
				foreach (Point p in listHexasInSight){
					int pos = p.x + p.y*hexaGrid.w;
					if (list[pos] < damage*c.PA) list[pos] = damage*c.PA;
				}
				
				// 1+ PM
				for (int i=1;i<c.PA;i++){
					List<Point> listH = hexaGrid.findAllPaths(c.x,c.y,c.PM*i);
					foreach (Point charpos in listH){
						listHexasInSight = hexaGrid.findHexasInSight(charpos.x,charpos.y,c.getClassData().basicAttack.range,out junk);
						foreach (Point p in listHexasInSight){
							int pos = p.x + p.y*hexaGrid.w;
							if (list[pos] < damage*(c.PA-i)) list[pos] = damage*(c.PA-i);
						}
					}
				}
				// Add to the list
				for (int i=0;i<w_h;i++){
					finalList[i] += list[i];
					list[i] = 0;
				}
			}
		}
		return finalList;
	}
	
	/** Calculates how much damage can potentially be dealt on each hexa.
		Returns a list of w*h that contains the data. */
	public static int[] calculateDamage(int charID){
		Character currentChar = hexaGrid.charList[charID];
		int w_h = hexaGrid.w * hexaGrid.h;
		int[] list = new int[w_h];
		for (int i=0;i<w_h;i++){
			list[i] = 0;
		}
		
		int damage = currentChar.getClassData().basicAttack.effectValue;
		// 0 PM
		foreach (Character c in hexaGrid.charList){
			if (c.team != currentChar.team){
				if (hexaGrid.hexaInSight(currentChar.x,currentChar.y,c.x,c.y,currentChar.getClassData().basicAttack.range)){
					int value = damage*currentChar.PA;
					if (c.HP <= value) value += 10;
					int pos = currentChar.x + currentChar.y*hexaGrid.w;
					if (list[pos] < value) list[pos] = value;
				}
			}
		}
		// 1+ PM
		for (int i=1;i<currentChar.PA;i++){
			List<Point> listH = hexaGrid.findAllPaths(currentChar.x,currentChar.y,currentChar.PM*i);
			foreach (Point charpos in listH){
				foreach (Character c in hexaGrid.charList){
					if (c.team != currentChar.team){
						if (hexaGrid.hexaInSight(charpos.x,charpos.y,c.x,c.y,currentChar.getClassData().basicAttack.range)){
							int value = damage*(currentChar.PA-i);
							if (c.HP <= value) value += 10;
							int pos = charpos.x + charpos.y*hexaGrid.w;
							if (list[pos] < value) list[pos] = value;
						}
					}
				}
			}
		}
		
		return list;
	}

	/** Calculates how much healing can potentially be done on each hexa
		assuming the character is a healer.
		Returns a list of w*h that contains the data.*/
	public static int[] calculateHealing(int charID){
		Character currentChar = hexaGrid.charList[charID];
		int w_h = hexaGrid.w * hexaGrid.h;
		int[] list = new int[w_h];
		for (int i=0;i<w_h;i++){
			list[i] = 0;
		}
		
		int healing = currentChar.getClassData().basicAttack.effectValue;
		// 0 PM
		foreach (Character c in hexaGrid.charList){
			if (c.team == currentChar.team){
				if (hexaGrid.hexaInSight(currentChar.x,currentChar.y,c.x,c.y,currentChar.getClassData().basicAttack.range)){
					int value = healing*currentChar.PA;
					if (c.HP+value > c.HPmax) value = c.HPmax-c.HP;
					int pos = currentChar.x + currentChar.y*hexaGrid.w;
					if (list[pos] < value) list[pos] = value;
				}
			}
		}
		// 1+ PM
		for (int i=1;i<currentChar.PA;i++){
			List<Point> listH = hexaGrid.findAllPaths(currentChar.x,currentChar.y,currentChar.PM*i);
			foreach (Point charpos in listH){
				foreach (Character c in hexaGrid.charList){
					if (c.team == currentChar.team){
						if (hexaGrid.hexaInSight(charpos.x,charpos.y,c.x,c.y,currentChar.getClassData().basicAttack.range)){
							int value = healing*(currentChar.PA-i);
							if (c.HP+value > c.HPmax) value = c.HPmax-c.HP;
							int pos = charpos.x + charpos.y*hexaGrid.w;
							if (list[pos] < value) list[pos] = value;
						}
					}
				}
			}
		}
		
		return list;
	}
	
	/** Calculates how many PAs can potentially be given on each hexa
		assuming the character is a envouteur.
		Returns a list of w*h that contains the data.*/
	public static int[] calculateBuff(int charID){
		Character currentChar = hexaGrid.charList[charID];
		int w_h = hexaGrid.w * hexaGrid.h;
		int[] list = new int[w_h];
		for (int i=0;i<w_h;i++){
			list[i] = 0;
		}
		
		int healing = currentChar.getClassData().basicAttack.effectValue;
		// 0 PM
		foreach (Character c in hexaGrid.charList){
			if (c.team == currentChar.team){
				if (hexaGrid.hexaInSight(currentChar.x,currentChar.y,c.x,c.y,currentChar.getClassData().basicAttack.range)){
					int value;
					switch (c.charClass){
						case CharClass.GUERRIER  : value = 3; break;
						case CharClass.VOLEUR    : value = 6; break;
						case CharClass.ARCHER    : value = 4; break;
						case CharClass.MAGE      : value = 5; break;
						case CharClass.SOIGNEUR  : value = 2; break;
						case CharClass.ENVOUTEUR : value = 1; break;
						default : value = 0; break;
					}
					int pos = currentChar.x + currentChar.y*hexaGrid.w;
					if (list[pos] < value) list[pos] = value;
				}
			}
		}
		// 1+ PM
		for (int i=1;i<currentChar.PA;i++){
			List<Point> listH = hexaGrid.findAllPaths(currentChar.x,currentChar.y,currentChar.PM*i);
			foreach (Point charpos in listH){
				foreach (Character c in hexaGrid.charList){
					if (c.team == currentChar.team){
						if (hexaGrid.hexaInSight(charpos.x,charpos.y,c.x,c.y,currentChar.getClassData().basicAttack.range)){
							int value;
							switch (c.charClass){
								case CharClass.GUERRIER  : value = 3; break;
								case CharClass.VOLEUR    : value = 6; break;
								case CharClass.ARCHER    : value = 4; break;
								case CharClass.MAGE      : value = 5; break;
								case CharClass.SOIGNEUR  : value = 2; break;
								case CharClass.ENVOUTEUR : value = 1; break;
								default : value = 0; break;
							}
							int pos = charpos.x + charpos.y*hexaGrid.w;
							if (list[pos] < value) list[pos] = value;
						}
					}
				}
			}
		}
		
		return list;
	}
	
	/** Returns the minimum number of steps to go from (x1,y1) to (x2,y2). */
	public static int getDistance(int x1,int y1,int x2,int y2){
		int maxSteps = 300;
		if (hexaGrid.getHexa(x1,y1).type == HexaType.WALL || hexaGrid.getHexa(x2,y2).type == HexaType.WALL) return -1;
		List<HexaGrid.HexaTemp> hexaList2 = new List<HexaGrid.HexaTemp>();
		foreach (Hexa hexa in hexaGrid.hexaList){
			hexaList2.Add(new HexaGrid.HexaTemp(hexa.x,hexa.y,maxSteps+1));
		}
		List<HexaGrid.HexaTemp> toCheck = new List<HexaGrid.HexaTemp>();
		toCheck.Add(new HexaGrid.HexaTemp(x1,y1,0));
		hexaList2[x1 + y1*hexaGrid.w].nbSteps = 0;
		int minSteps = maxSteps+1;
		
		while (toCheck.Count > 0){
			HexaGrid.HexaTemp p = toCheck[0];
			toCheck.RemoveAt(0);
			if (p.nbSteps < maxSteps && p.nbSteps < minSteps){
				for (int i=0;i<6;i++){
					HexaDirection hexaDirectionI = (HexaDirection)i;
					Point p2 = HexaGrid.findPos(p.x,p.y,hexaDirectionI);
					Hexa h = hexaGrid.getHexa(p2);
					if (h != null && ((h.x == x2 && h.y == y2) || (h.type == HexaType.GROUND && h.charOn == null)) && hexaList2[p2.x + p2.y*hexaGrid.w].nbSteps > p.nbSteps+1){
						hexaList2[p2.x + p2.y*hexaGrid.w].nbSteps = p.nbSteps+1;
						if (p2.x == x2 && p2.y == y2) minSteps = p.nbSteps+1;
						toCheck.Add(new HexaGrid.HexaTemp(p2.x,p2.y,p.nbSteps+1));
					}
				}
			}
		}
		
		return (hexaList2[x2+y2*hexaGrid.w].nbSteps == maxSteps) ? -1 : hexaList2[x2+y2*hexaGrid.w].nbSteps;
	}

	/** Returns the position of the hexas where the value is at its maximum in the list of possible hexas.
		Use calculateDamage,... to get v.*/
	public static List<Point> findHexasWhereValueIsMax(List<Point> possibleHexas,int[] v){
		// find best value
		int maxValue = v[possibleHexas[0].x+possibleHexas[0].y*hexaGrid.w];
		foreach (Point p in possibleHexas){
			int vmax = v[p.x+p.y*hexaGrid.w];
			if (vmax > maxValue) maxValue = vmax;
		}
		// find all hexas with best value
		List<Point> bestHexas = new List<Point>();
		foreach (Point p in possibleHexas){
			int vmax = v[p.x+p.y*hexaGrid.w];
			if (vmax == maxValue) bestHexas.Add(p);
		}
		return bestHexas;
	}
	
	/** Returns the position of the hexas where the least amount of potential damage will be taken in the list of possible hexas. */
	public static List<Point> findSafestHexas(List<Point> possibleHexas){
		return null; // TO DO
	}
	
	/** Returns the position of the hexas where the character will be closest to the lowest ennemy in the list of possible hexas. */
	public static List<Point> findHexasClosestToLowestEnnemy(int charID,List<Point> possibleHexas){
		Character currentChar = hexaGrid.charList[charID];
		int minDistance = 100000;
		Character cLowest = AIUtil.findLowestEnnemy(currentChar.team);
		// find best value
		List<int> possibleHexasValues = new List<int>();
		foreach (Point p in possibleHexas){
			int d = AIUtil.getDistance(p.x,p.y,cLowest.x,cLowest.y);
			possibleHexasValues.Add(d);
			if (d != -1) if (d < minDistance) minDistance = d;
		}
		// find all hexas with best value
		List<Point> bestHexas = new List<Point>();
		for (int i=0;i<possibleHexas.Count;i++) if (possibleHexasValues[i] == minDistance) bestHexas.Add(possibleHexas[i]);
		return bestHexas;
	}
	
	/** Returns the position of the hexas where the character will be closest to allies in the list of possible hexas. */
	public static List<Point> findHexasClosestToAllies(int charID,List<Point> possibleHexas){
		Character currentChar = hexaGrid.charList[charID];
		Point charPos = new Point(currentChar.x,currentChar.y);
		List<Point> bestHexas = new List<Point>();
		int closest = 100000;
		// SOIGNEUR
		if (currentChar.charClass == CharClass.SOIGNEUR){
			List<int> possibleHexasValues = new List<int>();
			foreach (Point p in possibleHexas){
				currentChar.updatePos(p.x,p.y,hexaGrid);
				Character cLowest = findCharToHeal(charID);
				if (cLowest != null){
					possibleHexasValues.Add(cLowest.HP);
					if (cLowest.HP < closest) closest = cLowest.HP;
				}else{
					possibleHexasValues.Add(100000);
				}
			}
			for (int i=0;i<possibleHexas.Count;i++) if (possibleHexasValues[i] == closest) bestHexas.Add(possibleHexas[i]);
			currentChar.updatePos(charPos.x,charPos.y,hexaGrid);
			return bestHexas;
		// OTHERS
		}else{
			List<int> possibleHexasValues = new List<int>();
			foreach (Point p in possibleHexas){
				currentChar.updatePos(p.x,p.y,hexaGrid);
				int distance = 0;
				foreach (Character c in hexaGrid.charList){
					if (c.team == currentChar.team && c != currentChar) distance += getDistance(p.x,p.y,c.x,c.y);
				}
				possibleHexasValues.Add(distance);
				if (distance < closest) closest = distance;
			}
			for (int i=0;i<possibleHexas.Count;i++) if (possibleHexasValues[i] == closest) bestHexas.Add(possibleHexas[i]);
			currentChar.updatePos(charPos.x,charPos.y,hexaGrid);
			return bestHexas;
		}
	}

	
	public static List<ActionAIPos> findSequencePathToHexa(int charID,int x,int y){
		Character currentChar = hexaGrid.charList[charID];
		List<ActionAIPos> sequence = new List<ActionAIPos>();
		int nbPA = currentChar.PA;
		if (x == currentChar.x && y == currentChar.y){
			
		}else{
			int d = AIUtil.getDistance(currentChar.x,currentChar.y,x,y);
			List<Point> shortestPath = hexaGrid.findShortestPath(currentChar.x,currentChar.y,x,y,d);
			for (int i=0;i<=d && nbPA > 0;i+=currentChar.PM){
				Point destination = shortestPath[((i+currentChar.PM) <= d) ? (i+currentChar.PM) : d];
				sequence.Add(new ActionAIPos(MainGame.ActionType.MOVE,new Point(destination.x,destination.y)));
				nbPA--;
			}
		}
		return sequence;
	}
	
	/** Returns the ennemy with the lowest amount of HP. */
	public static Character findLowestEnnemy(int myTeam){
		int lowest = 100000;
		Character cLowest = null;
		foreach (Character c in hexaGrid.charList){
			if (c.team != myTeam && c.HP < lowest){
				lowest = c.HP;
				cLowest = c;
			}
		}
		return cLowest;
	}
	
	/** Returns the ID of the ennemy that either will be killed or be lowest after
		being attacked from the current char pos. */
	public static Character findCharToAttack(int myCharID){
		Character currentChar = hexaGrid.charList[myCharID];
		int lowest = 100000;
		Character cLowest = null;
		foreach (Character c in hexaGrid.charList){
			if (c.team != currentChar.team){
				if (hexaGrid.hexaInSight(currentChar.x,currentChar.y,c.x,c.y,currentChar.getClassData().basicAttack.range)){
					if (c.HP < lowest){
						lowest = c.HP;
						cLowest = c;
					}
				}
			}
		}
		return cLowest;
	}
	
	/** Returns the ID of the ennemy that either will be killed or be lowest after
		being attacked with skill from the current char pos. */
	public static Character findCharToAttackSkill(int myCharID){
		Character currentChar = hexaGrid.charList[myCharID];
		int lowest = 100000;
		Character cLowest = null;
		foreach (Character c in hexaGrid.charList){
			if (c.team != currentChar.team){
				if (hexaGrid.hexaInSight(currentChar.x,currentChar.y,c.x,c.y,currentChar.getClassData().skill_1.range)){
					if (c.HP < lowest){
						lowest = c.HP;
						cLowest = c;
					}
				}
			}
		}
		return cLowest;
	}
	
	/** Returns the ID of the ally that can be healed for the most
		from the current char pos assuming the character is a healer. */
	public static Character findCharToHeal(int myCharID){
		Character currentChar = hexaGrid.charList[myCharID];
		int highest = 0;
		Character cHighest = null;
		foreach (Character c in hexaGrid.charList){
			if (c.team == currentChar.team && c != currentChar){
				if (hexaGrid.hexaInSight(currentChar.x,currentChar.y,c.x,c.y,currentChar.getClassData().basicAttack.range)){
					if (c.HPmax-c.HP > highest){
						highest = c.HP;
						cHighest = c;
					}
				}
			}
		}
		return cHighest;
	}
	
	/** Returns the ID of the ally that can be buffed for the most
		from the current char pos assuming the character is a envouteur. */
	public static Character findCharToBuff(int myCharID){
		Character currentChar = hexaGrid.charList[myCharID];
		int highest = 0;
		Character cHighest = null;
		foreach (Character c in hexaGrid.charList){
			if (c.team == currentChar.team && c != currentChar){
				if (hexaGrid.hexaInSight(currentChar.x,currentChar.y,c.x,c.y,currentChar.getClassData().basicAttack.range)){
					int classPrio;
					switch (c.charClass){
						case CharClass.GUERRIER  : classPrio = 3; break;
						case CharClass.VOLEUR    : classPrio = 6; break;
						case CharClass.ARCHER    : classPrio = 4; break;
						case CharClass.MAGE      : classPrio = 5; break;
						case CharClass.SOIGNEUR  : classPrio = 2; break;
						case CharClass.ENVOUTEUR : classPrio = 1; break;
						default : classPrio = 0; break;
					}
					if (classPrio > highest){
						highest = classPrio;
						cHighest = c;
					}
				}
			}
		}
		return cHighest;
	}

	// -----------------------------------------------------------------------------------------------------------------------------------------------------------------
	// Functions used for AI HARD
	// -----------------------------------------------------------------------------------------------------------------------------------------------------------------
	
	public static int calculateThreatAtHexa(int x,int y,int team){
		int threat = 0;
		foreach (Character c in hexaGrid.charList){
			if (c.team != team && c.charClass != CharClass.SOIGNEUR && c.charClass != CharClass.ENVOUTEUR){
				int damage = 0;
				// 0 PM
				if (hexaGrid.hexaInSight(c.x,c.y,x,y,c.getClassData().basicAttack.range)){
					damage = c.getClassData().basicAttack.effectValue * c.PA;
				}
				
				// 1+ PM
				for (int i=1;i<c.PA;i++){
					if (damage == 0){
						List<Point> listH = hexaGrid.findAllPaths(c.x,c.y,c.PM*i);
						foreach (Point charpos in listH){
							if (hexaGrid.hexaInSight(charpos.x,charpos.y,x,y,c.getClassData().basicAttack.range)){
								damage = c.getClassData().basicAttack.effectValue * c.PA*(c.PA-i);
								break;
							}
						}
					}else{
						i = c.PA;
					}
				}
				threat += damage;
			}
		}
		return threat;
	}
	
	public static int getNbMaxTargets(int charID){
		int maxTargets = 0;
		Character currentChar = hexaGrid.charList[charID];
		List<Point> hexas = hexaGrid.findHexasInSight2(currentChar.x,currentChar.y,currentChar.getClassData().skill_1.range);
		foreach (Point p in hexas){
			
			List<Character> lc = hexaGrid.getCharWithinRange(p.x,p.y,currentChar.getClassData().skill_1.rangeAoE);
			int nb = 0;
			foreach (Character c in lc){
				if (c.team != currentChar.team) nb++;
			}
			if (nb > maxTargets) maxTargets = nb;
		}
		return maxTargets;
	}
	
	public static List<Point> findHexasWhereDamageIsHighest(int charID,List<Point> possibleHexas){
		Character currentChar = hexaGrid.charList[charID];
		int minDistance = 100000;
		Character cLowest = AIUtil.findLowestEnnemy(currentChar.team);
		// find best value
		List<int> possibleHexasValues = new List<int>();
		foreach (Point p in possibleHexas){
			int d = AIUtil.getDistance(p.x,p.y,cLowest.x,cLowest.y);
			possibleHexasValues.Add(d);
			if (d != -1) if (d < minDistance) minDistance = d;
		}
		// find all hexas with best value
		List<Point> bestHexas = new List<Point>();
		for (int i=0;i<possibleHexas.Count;i++){
			if (possibleHexasValues[i] == minDistance){
				bestHexas.Add(possibleHexas[i]);
			}
		}
		return bestHexas;
	}
	
	public class AIHard {
		public static ActionAIPos doApproachEnnemy(int myCharID){
			Character currentChar = hexaGrid.charList[myCharID];
			Character cLowest = AIUtil.findLowestEnnemy(currentChar.team);
			List<Point> listH = hexaGrid.findAllPaths(currentChar.x,currentChar.y,currentChar.PM);
			if (listH != null && listH.Count > 0){
				// Find hexas where damage dealt is highest
				List<Point> bestHexas  = AIUtil.findHexasWhereValueIsMax(listH,AIUtil.calculateDamage(myCharID));
				// Find hexas where position to lowest ennemy is lowest
				List<Point> bestHexas2 = AIUtil.findHexasClosestToLowestEnnemy(myCharID,bestHexas);
				Point bestHexa = bestHexas2[0];
				if (bestHexa.x == currentChar.x && bestHexa.y == currentChar.y) return new ActionAIPos(MainGame.ActionType.SKIP,null);
				else return new ActionAIPos(MainGame.ActionType.MOVE,bestHexa);
			}else{
				return new ActionAIPos(MainGame.ActionType.SKIP,null);
			}
		}
		
		public static ActionAIPos doApproachAlly(int myCharID){
			Character currentChar = hexaGrid.charList[myCharID];
			Character cLowest = AIUtil.findLowestEnnemy(currentChar.team);
			List<Point> listH = hexaGrid.findAllPaths(currentChar.x,currentChar.y,currentChar.PM);
			if (listH != null && listH.Count > 0){
				// Find hexas where position is closest to allies
				List<Point> bestHexas  = AIUtil.findHexasClosestToAllies(myCharID,listH);
				// Find hexas where position to lowest ennemy is lowest
				List<Point> bestHexas2 = AIUtil.findHexasClosestToLowestEnnemy(myCharID,bestHexas);
				Point bestHexa = bestHexas2[0];
				if (bestHexa.x == currentChar.x && bestHexa.y == currentChar.y) return new ActionAIPos(MainGame.ActionType.SKIP,null);
				else return new ActionAIPos(MainGame.ActionType.MOVE,bestHexa);
			}else{
				return new ActionAIPos(MainGame.ActionType.SKIP,null);
			}
		}
		
		public static ActionAIPos doRandomMovement(int myCharID){
			return new ActionAIPos(MainGame.ActionType.SKIP,null);
		}
		
		public static ActionAIPos doFlee(int myCharID){
			Character currentChar = hexaGrid.charList[myCharID];
			Character cLowest = AIUtil.findLowestEnnemy(currentChar.team);
			List<Point> listH = hexaGrid.findAllPaths(currentChar.x,currentChar.y,currentChar.PM);
			if (listH != null && listH.Count > 0){
				// Find hexas where threat is lowest
				List<Point> bestHexas  = AIUtil.findHexasWhereValueIsMax(listH,AIUtil.calculateThreat(myCharID));
				// Find hexas where position is closest to allies
				List<Point> bestHexas2 = AIUtil.findHexasClosestToAllies(myCharID,bestHexas);
				Point bestHexa = bestHexas2[0];
				if (bestHexa.x == currentChar.x && bestHexa.y == currentChar.y) return new ActionAIPos(MainGame.ActionType.SKIP,null);
				else return new ActionAIPos(MainGame.ActionType.MOVE,bestHexa);
			}else{
				return new ActionAIPos(MainGame.ActionType.SKIP,null);
			}
		}
		
		public static ActionAIPos doAttack(int myCharID,int targetID){
			Character cAttack = AIUtil.findCharToAttack(myCharID);
			if (cAttack != null){
				return new  ActionAIPos(MainGame.ActionType.ATK1,new Point(cAttack.x,cAttack.y));
			}else{
				return new ActionAIPos(MainGame.ActionType.SKIP,null);
			}
		}
		
		public static ActionAIPos doSkill(int myCharID,int targetID){
			Character cAttack = AIUtil.findCharToAttackSkill(myCharID);
			if (cAttack != null){
				return new  ActionAIPos(MainGame.ActionType.ATK1,new Point(cAttack.x,cAttack.y));
			}else{
				return new ActionAIPos(MainGame.ActionType.SKIP,null);
			}
		}
	}

}

}